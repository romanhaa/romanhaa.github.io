<!DOCTYPE html>
<html lang="en-us"><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="generator" content="Hugo 0.57.2" />
  
  <title>Roman Hillje - Data Visualization &amp; Bioinformatics</title>
  
  
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i">
  <link rel="stylesheet" href="/css/medium.css">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
  <div class="container pr-0">

    
    <a class="navbar-brand" href="http://romanhaa.github.io/">
      
      <span style="font-family:Righteous;">Roman Hillje - Data Visualization &amp; Bioinformatics</span>
      
    </a>

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    
    <div class="collapse navbar-collapse" id="navbarMediumish">
      
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item ">
          <a class="nav-link" href="/">About Me</a>
        </li>
        
        <li class="nav-item ">
          <a class="nav-link" href="/blog">Blog</a>
        </li>
        
        <li class="nav-item ">
          <a class="nav-link" href="/plots">Plot Gallery</a>
        </li>
        
        <li class="nav-item ">
          <a class="nav-link" href="/projects">Projects</a>
        </li>
        
      </ul>
    </div>

  </div>
</nav>

<div class="site-content">
      <div class="container">
  <div class="main-content">

    
    <div class="container">
      <div class="row">

        
        <div class="col-md-12 flex-first flex-md-unordered">
          <div class="mainheading">

            
            <h1 class="posttitle">Porting PAGA results from scanpy to R</h1>
            <div class="article-post">
              Apr 16, 2019
            </div>

          </div>
          
          

          
          <div class="article-post">
            

<p><a href="https://satijalab.org/seurat/">Seurat</a> and <a href="https://scanpy.readthedocs.io/en/latest/#">scanpy</a> are both great frameworks to analyze single-cell RNA-seq data, the main difference being the language they are designed for.
Most of the methods frequently used in the literature are available in both toolkits and the workflow is essentially the same.
However, Fabian Theis and his group (with special credit to Alex Wolf) have recently published their <a href="https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1663-x">PAGA</a> algorithm that attempts to harmonize dimensional reduction with clustering and trajectory analysis.
This is very exciting and a step in the right direction as tSNE and UMAP are known to have limitations in this regard.
However, if you are a heavy Seurat/R user, you will be bummed to hear that for now (at least to my knowledge) no R port of PAGA exists and I&rsquo;m not sure the authors have intentions to change this.
As far as I know, Cole Trapnell and his lab are working on implementing something similar, if not precisely the PAGA algorithm, in <a href="http://cole-trapnell-lab.github.io/monocle-release/monocle3/">Monocle 3</a>.</p>

<p>For those of you who do most of their analysis in Seurat and want to perform PAGA analysis (and/or can&rsquo;t wait for Monocle 3), I explain here how to do so.</p>

<h3 id="requirements">Requirements</h3>

<ul>
<li><code>Seurat</code> <strong>v2</strong>.x; unfortunately, the <code>Convert()</code> function in Seurat v3 doesn&rsquo;t seem to be able yet to export the Seurat object to the anndata format (which is what we need).</li>
<li>The <code>reticulate</code> R package for communication  between R and Python.</li>
<li><code>scanpy</code>; I installed it using <code>pip3</code>.</li>
</ul>

<p>I also use the <code>tidyverse</code> R meta package but they are not technically required as the respective commands can be replaced.</p>

<h3 id="let-s-get-started">Let&rsquo;s get started</h3>

<p>First we load the packages mentioned above.</p>

<pre><code class="language-r">library(&quot;Seurat&quot;)
library(&quot;tidyverse&quot;)
library(&quot;reticulate&quot;)
</code></pre>

<p>Then we load a Seurat object (this one here was created with <code>Seurat</code> v2.3.4), convert it to the anndata format and save it to a file.</p>

<pre><code class="language-r">seurat &lt;- readRDS(&quot;seurat.rds&quot;)

seurat_ad &lt;- Convert(
  from = seurat,
  to = &quot;anndata&quot;,
  filename = &quot;seurat.h5ad&quot;
)
</code></pre>

<h4 id="apply-paga-and-umap">Apply PAGA and UMAP</h4>

<p>Now we use the <code>reticulate</code> package to&hellip;</p>

<ul>
<li>load <code>scanpy</code></li>
<li>load the exported anndata file (<code>sc.read()</code>)</li>
<li>find neighbors (<code>sc.pp.neighbors()</code>)</li>
<li>cluster cells using the Leiden algorithm (<code>sc.tl.leiden()</code>)</li>
<li>run PAGA analysis (<code>sc.tl.paga()</code>) and give it a visual check (<code>sc.pl.paga()</code>)</li>
<li>generate a UMAP using the PAGA results as initial positions (<code>sc.tl.umap()</code>)</li>

<li><p>plot UMAP and PAGA side-by-side (<code>sc.pl.paga_compare()</code>)</p>

<pre><code class="language-r">sc &lt;- import(&quot;scanpy&quot;, convert = FALSE)

adata = sc$read(&quot;seurat.h5ad&quot;)

sc$pp$neighbors(adata)
sc$tl$leiden(adata, resolution = 1.0)

sc$tl$paga(adata, groups = &quot;leiden&quot;)
sc$pl$paga(adata)

sc$tl$umap(adata, init_pos = &quot;paga&quot;)

sc$pl$paga_compare(
adata,
basis = &quot;umap&quot;,
threshold = 0.15,
edge_width_scale = 0.5,
save = TRUE
)
</code></pre></li>
</ul>




<figure>
  <img src="/images/blog/PAGA/scanpy_umap_paga.png" alt="UMAP_PAGA" style="width: 100%"/>
  <figcaption style="text-align: center">PAGA on the basis of Leiden clusters and derived UMAP plotted with scanpy.</figcaption>
</figure>



<p><strong>Notes:</strong></p>

<ul>
<li>In the previous step we stored the converted Seurat object to disk only to then load it again as an anndata file. This might seem a little silly since we could also use that object directly. However, I ran into some problems with automatic conversion of Python objects to R which can be circumvented by loading the exported file with automatic conversion switched off (<code>import(&quot;scanpy&quot;, convert=FALSE)</code>).</li>
<li>Be aware that Python and R start arrays with different indices, namely 0 and 1, respectively.</li>
</ul>

<h4 id="export-results-and-store-in-seurat-object">Export results and store in Seurat object</h4>

<p>Next, we store the results in our Seurat object.
This is technically not necessary but I think it&rsquo;s good practice to keep all results in a single file.</p>

<pre><code class="language-r">seurat@meta.data$leiden &lt;- py_to_r(adata$obs$leiden)

paga &lt;- list(
  connectivities = py_to_r(adata$uns$paga$connectivities$todense()),
  connectivities_tree = py_to_r(adata$uns$paga$connectivities$todense()),
  group_name = py_to_r(adata$uns$paga$groups),
  groups = levels(py_to_r(adata$obs$leiden)),
  group_colors = setNames(py_to_r(adata$uns$leiden_colors), c(0:(nrow(py_to_r(adata$uns$paga$pos))-1))),
  position = tibble(
    group = levels(py_to_r(adata$obs$leiden)),
    x = as.data.frame(py_to_r(adata$uns$paga$pos))$V1,
    y = as.data.frame(py_to_r(adata$uns$paga$pos))$V2
  ),
  umap = tibble(
    UMAP_1 = as.data.frame(py_to_r(adata$obsm$X_umap))$V1,
    UMAP_2 = as.data.frame(py_to_r(adata$obsm$X_umap))$V2
  )
)

rownames(paga$connectivities) &lt;- c(1:nrow(paga$pos))
colnames(paga$connectivities) &lt;- c(1:nrow(paga$pos))

seurat@misc$paga &lt;- paga
</code></pre>

<h4 id="process-paga-results">Process PAGA results</h4>

<p>Then we turn the PAGA results in a plot-able format.</p>

<pre><code class="language-r">paga_edges &lt;- tibble(
  group1 = rownames(paga$connectivities)[row(paga$connectivities)[upper.tri(paga$connectivities)]],
  group2 = colnames(paga$connectivities)[col(paga$connectivities)[upper.tri(paga$connectivities)]],
  weight = paga$connectivities[upper.tri(paga$connectivities)]
) %&gt;%
mutate(
  x1 = paga$position$x[match(.$group1, rownames(paga$position))],
  y1 = paga$position$y[match(.$group1, rownames(paga$position))],
  x2 = paga$position$x[match(.$group2, rownames(paga$position))],
  y2 = paga$position$y[match(.$group2, rownames(paga$position))]
) %&gt;%
filter(weight &gt;= 0.15)
</code></pre>

<p>We have removed all connections with a weight lower than <code>0.15</code>.
This value was arbitrarily chosen and you can adjust this to your data set.
The lower the cut-off, the more connection will be visible.</p>

<h4 id="plot-paga-with-ggplot2">Plot PAGA with ggplot2</h4>

<p>Now we can plot the graph generated by PAGA and the derived UMAP using <code>ggplot2</code>, in particular <code>geom_segment</code>.</p>

<pre><code class="language-r">paga &lt;- ggplot(paga$position, aes(x, y)) +
geom_segment(
  data = paga_edges,
  aes(x = x1, y = y1, xend = x2, yend = y2),
  size = paga_edges$weight*3,
  colour = &quot;black&quot;,
  show.legend = FALSE
) +
geom_point(aes(color = group), size = 7, alpha = 1, show.legend = FALSE) +
scale_color_manual(values = paga$group_colors) +
geom_text(aes(label = group), color = &quot;black&quot;, fontface = &quot;bold&quot;) +
labs(x = &quot;UMAP_1&quot;, y = &quot;UMAP_2&quot;) +
theme_bw() +
theme(
  axis.title = element_blank(),
  axis.text = element_blank(),
  axis.ticks = element_blank(),
  axis.line = element_blank(),
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  panel.border = element_blank()
)

ggsave(paga, filename = &quot;r_paga.pdf&quot;, height = 5, width = 7)
ggsave(paga, filename = &quot;r_paga.png&quot;, height = 5, width = 7)
</code></pre>

<pre><code class="language-r">umap &lt;- tibble(
  UMAP_1 = paga$umap$UMAP_1,
  UMAP_2 = paga$umap$UMAP_2,
  group = py_to_r(adata$obs$leiden)
)

group_centers &lt;- umap %&gt;%
  group_by(group) %&gt;%
  summarize(x = median(UMAP_1), y = median(UMAP_2))

umap_plot &lt;- umap %&gt;%
ggplot(aes(UMAP_1, UMAP_2, color = group)) +
geom_point(size = 0.1, show.legend = FALSE) +
geom_text(
  data = group_centers,
  mapping = aes(x, y, label = group),
  size = 4.5,
  color = &quot;black&quot;,
  fontface = &quot;bold&quot;,
  show.legend = FALSE
) +
scale_color_manual(values = paga$group_colors) +
theme_bw() +
theme(
  axis.title = element_blank(),
  axis.text = element_blank(),
  axis.ticks = element_blank(),
  axis.line = element_blank(),
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  panel.border = element_blank()
)

ggsave(umap_plot, filename = &quot;r_umap.pdf&quot;, height = 5, width = 7)
ggsave(umap_plot, filename = &quot;r_umap.png&quot;, height = 5, width = 7)
</code></pre>




<figure>
  <img src="/images/blog/PAGA/r_umap.png" alt="UMAP" style="width: 50%"/><img src="/images/blog/PAGA/r_paga.png" alt="PAGA" style="width: 50%"/>
  <figcaption style="text-align: center">PAGA on the basis of Leiden clusters and derived UMAP plotted with ggplot2.</figcaption>
</figure>



<h4 id="result">Result</h4>

<p>Direct comparison <code>scanpy</code> vs <code>ggplot2</code>:</p>




<figure>
  <img src="/images/blog/PAGA/scanpy_paga.png" alt="PAGA" style="width: 50%"/><img src="/images/blog/PAGA/r_paga.png" alt="UMAP" style="width: 50%"/>
  <figcaption style="text-align: center">PAGA plots of scanpy (left) and ggplot2 (right).</figcaption>
</figure>



<h3 id="adaptation-for-rna-velocity-based-transitions-between-clusters">Adaptation for RNA velocity-based transitions between clusters</h3>

<p><code>scanpy</code> offers to use RNA velocity information to predict transitions between clusters in the PAGA results.
I won&rsquo;t go into detail on how to do that but can recommend to use <a href="https://scvelo.readthedocs.io/en/latest/#"><code>scVelo</code></a> which directly integrates into the <code>scanpy</code> framework.
Here, I&rsquo;ll assume you have already generated the PAGA using RNA velocity data, e.g. as shown below.</p>

<pre><code class="language-r">sc$tl$paga(adata, groups = &quot;leiden&quot;, use_rna_velocity = TRUE)
sc$pl$paga(
  adata,
  basis = &quot;umap&quot;,
  threshold = 0.15,
  arrowsize = 10,
  edge_width_scale = 0.5,
  transitions = &quot;transitions_confidence&quot;,
  dashed_edges = &quot;connectivities&quot;,
  save = TRUE
)
</code></pre>




<figure>
  <img src="/images/blog/PAGA/scanpy_umap_paga_velocity.png" alt="UMAP_PAGA_velocity" style="width: 100%"/>
  <figcaption style="text-align: center">PAGA on the basis of Leiden clusters and derived UMAP plotted with scanpy.</figcaption>
</figure>



<h4 id="extract-paga-results">Extract PAGA results</h4>

<p>When exporting the results to R and plotting them with <code>ggplot2</code> we will have to extract more information and add a layer for the transition arrows.
Below you can see the same step as before, however also extracting the <code>transitions_confidence</code> matrix that represents the RNA velocity results.</p>

<pre><code class="language-r">paga &lt;- list(
  connectivities = py_to_r(adata$uns$paga$connectivities$todense()),
  connectivities_tree = py_to_r(adata$uns$paga$connectivities$todense()),
  transitions_confidence = py_to_r(adata$uns$paga$transitions_confidence$todense()),
  group_name = py_to_r(adata$uns$paga$groups),
  groups = levels(py_to_r(adata$obs$leiden)),
  group_colors = setNames(py_to_r(adata$uns$leiden_colors), c(0:(nrow(py_to_r(adata$uns$paga$pos))-1))),
  position = tibble(
    group = levels(py_to_r(adata$obs$leiden)),
    x = as.data.frame(py_to_r(adata$uns$paga$pos))$V1,
    y = as.data.frame(py_to_r(adata$uns$paga$pos))$V2
  ),
  umap = tibble(
    UMAP_1 = as.data.frame(py_to_r(adata$obsm$X_umap))$V1,
    UMAP_2 = as.data.frame(py_to_r(adata$obsm$X_umap))$V2
  )
)

rownames(paga$connectivities) &lt;- c(1:nrow(paga$pos))
colnames(paga$connectivities) &lt;- c(1:nrow(paga$pos))

rownames(paga$transitions_confidence) &lt;- c(1:nrow(paga$pos))
colnames(paga$transitions_confidence) &lt;- c(1:nrow(paga$pos))
</code></pre>

<pre><code class="language-r">seurat@misc$paga &lt;- paga
</code></pre>

<h4 id="transform-matrices-to-tibbles">Transform matrices to tibbles</h4>

<p>Then, we generate tibbles that contain information about the connectivities between clusters (<code>paga_edges</code>) as well as the transition confidence (<code>paga_arrows</code>).</p>

<pre><code class="language-r">paga_edges &lt;- tibble(
  group1 = rownames(paga$connectivities)[row(paga$connectivities)[upper.tri(paga$connectivities)]],
  group2 = colnames(paga$connectivities)[col(paga$connectivities)[upper.tri(paga$connectivities)]],
  weight = paga$connectivities[upper.tri(paga$connectivities)]
) %&gt;%
mutate(
  x1 = paga$position$x[match(.$group1, rownames(paga$position))],
  y1 = paga$position$y[match(.$group1, rownames(paga$position))],
  x2 = paga$position$x[match(.$group2, rownames(paga$position))],
  y2 = paga$position$y[match(.$group2, rownames(paga$position))]
)
</code></pre>

<p>Next, we need to convert the transition confidences into a format that <code>ggplot2</code>, more precisely the <code>geom_segment</code> function, can handle.
To do so, we&hellip;</p>

<ul>
<li>create an empty tibble for the data</li>
<li>check the transition confidence for every combination of clusters</li>
<li>check which direction is more confident and store only that value</li>
<li>skip comparisons between clusters that have already been done</li>
<li>shorten the arrow to avoid overlap with the cluster nodes</li>
</ul>

<p>There is probably a more elegant way to do this, perhaps using tools such as <a href="https://briatte.github.io/ggnetwork/"><code>ggnetwork</code></a> or <a href="https://briatte.github.io/ggnet/"><code>ggnet2</code></a>, but this gets the job done for now.</p>

<pre><code class="language-r">paga_arrows &lt;- tibble(
  group1 = character(),
  group2 = character(),
  weight = double(),
  x1 = double(),
  y1 = double(),
  x2 = double(),
  y2 = double()
)

paga_arrows_dimensions &lt;- nrow(paga$transitions_confidence)

comparisons_done &lt;- c()

arrow_gap &lt;- 0.5

for ( i in 1:paga_arrows_dimensions ) {
  # loop through columns
  for ( j in 1:paga_arrows_dimensions ) {
    # skip cell if on diagonal
    if ( i == j ) {
      next
    # skip cell if transition between these clusters has already been extracted
    } else if ( paste0(i, &quot;/&quot;, j) %in% comparisons_done | paste0(j, &quot;/&quot;, i) %in% comparisons_done ) {
      next
    # if none of the above, go ahead
    } else {
      # get value for transition i to j
      i_to_j &lt;- paga$transitions_confidence[j,i]
      # get value for transition j to i (other side of diagonal)
      j_to_i &lt;- paga$transitions_confidence[i,j]
      # if i to j is more confident than j to i
      if ( i_to_j &gt; j_to_i ) {
        x1 &lt;- paga$position$x[i]
        y1 &lt;- paga$position$y[i]
        x2 &lt;- paga$position$x[j]
        y2 &lt;- paga$position$y[j]
        x_length = x2 - x1
        y_length = y2 - y1
        gap = arrow_gap / sqrt(x_length ^ 2 + y_length ^ 2)
        x1_new = x1 + gap * x_length
        y1_new = y1 + gap * y_length
        x2_new = x1 + (1 - gap) * x_length
        y2_new = y1 + (1 - gap) * y_length
        new_entry &lt;- tibble(
          group1 = (i - 1),
          group2 = (j - 1),
          weight = i_to_j,
          x1 = x1_new,
          y1 = y1_new,
          x2 = x2_new,
          y2 = y2_new
        )
        paga_arrows &lt;- rbind(
          paga_arrows,
          new_entry
        )
      # if j to i is more confident than i to j
      } else if ( j_to_i &gt; i_to_j ) {
        x1 &lt;- paga$position$x[j]
        y1 &lt;- paga$position$y[j]
        x2 &lt;- paga$position$x[i]
        y2 &lt;- paga$position$y[i]
        x_length = x2 - x1
        y_length = y2 - y1
        gap = arrow_gap / sqrt(x_length ^ 2 + y_length ^ 2)
        x1_new = x1 + gap * x_length
        y1_new = y1 + gap * y_length
        x2_new = x1 + (1 - gap) * x_length
        y2_new = y1 + (1 - gap) * y_length
        new_entry &lt;- tibble(
          group1 = (j - 1),
          group2 = (i - 1),
          weight = j_to_i,
          x1 = x1_new,
          y1 = y1_new,
          x2 = x2_new,
          y2 = y2_new
        )
        paga_arrows &lt;- rbind(
          paga_arrows,
          new_entry
        )
      # else (for example both 0)
      } else {
        next
      }
      # add comparison to list of already performed comparisons
      comparisons_done &lt;- c(comparisons_done, paste0(i,&quot;/&quot;,j))
    }
  }
}
</code></pre>

<h4 id="filter-connections">Filter connections</h4>

<p>Similar to what we&rsquo;ve done before, we remove connections and arrows below a threshold of confidence.
Here, this threshold is <code>0.15</code>.</p>

<pre><code class="language-r">paga_edges &lt;- paga_edges %&gt;%
  filter(weight &gt;= 0.15)

paga_arrows &lt;- paga_arrows %&gt;%
  filter(weight &gt;= 0.15)
</code></pre>

<h4 id="plotting">Plotting</h4>

<p>Finally, we put everything together.
These are the steps:</p>

<ul>
<li>Set up plot.</li>
<li>Add connectivities between clusters using dashed lines.</li>
<li>Add arrows between clusters.</li>
<li>Add cluster nodes.</li>
<li>Add text to cluster nodes.</li>
<li>Customize cluster color and layout.</li>

<li><p>Save plot to file.</p>

<pre><code class="language-r">plot &lt;- ggplot()

plot &lt;- plot + geom_segment(
data = paga_edges,
aes(x = x1, y = y1, xend = x2, yend = y2),
size = paga_edges$weight*3,
linetype = 2,
colour = &quot;grey&quot;,
alpha = 0.75,
show.legend = FALSE
)

plot &lt;- plot + geom_segment(
data = paga_arrows,
aes(x = x1, y = y1, xend = x2, yend = y2),
size = paga_arrows$weight*3,
arrow = arrow(length = unit(0.02, &quot;npc&quot;), type = &quot;closed&quot;),
show.legend = FALSE
)

plot &lt;- plot + geom_point(
data = paga$position,
aes(x, y, color = group),
size = 7,
show.legend = FALSE
)

plot &lt;- plot + geom_text(
data = paga$position,
aes(x, y, label = group),
color = &quot;black&quot;,
fontface = &quot;bold&quot;
)

plot &lt;- plot + scale_color_manual(values = paga$group_colors) +
labs(x = &quot;UMAP_1&quot;, y = &quot;UMAP_2&quot;) +
theme_bw() +
theme(
axis.title = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.line = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank()
)

ggsave(plot = plot, filename = &quot;r_paga_velocity.pdf&quot;, height = 5, width = 7)
ggsave(plot = plot, filename = &quot;r_paga_velocity.png&quot;, height = 5, width = 7)
</code></pre></li>
</ul>

<p>Note that there are some parameters that you might have to adjust:</p>

<ul>
<li><code>arrow_gap</code>: How much to shorten the length of the transition arrows.</li>
<li>Filter threshold for connectivities and transitions, here set to <code>0.15</code>.</li>
<li>Scaling factors for connectivities (dashed lines) and transitions (arrows), currently set to <code>3</code>.</li>
</ul>

<h4 id="result-1">Result</h4>

<p>Direct comparison <code>scanpy</code> vs <code>ggplot2</code>:</p>




<figure>
  <img src="/images/blog/PAGA/scanpy_paga_velocity.png" alt="PAGA" style="width: 50%"/><img src="/images/blog/PAGA/r_paga_velocity.png" alt="UMAP" style="width: 50%"/>
  <figcaption style="text-align: center">PAGA plots with transition confidence of scanpy (left) and ggplot2 (right).</figcaption>
</figure>



<p>From here you can tweak the plots as you prefer, for example by scaling the point size in the PAGA results by the number of cells in that group/cluster.</p>

<p>Parameter optimization is another topic, but I find this analysis very useful to understand the relationship between identified clusters.</p>

<p><strong>That&rsquo;s it for now.</strong>
You can use the same process explained here to perform other analysis provided by <code>scanpy</code>, such as diffusion pseudotime (<code>tl.dpt()</code>).</p>

<p>If you have questions, comments, point out improvements/errors or simply reach out, please do so on Twitter <a href="https://twitter.com/fakechek1">@fakechek1</a></p>

<h3 id="session-info">Session info</h3>

<p>Analysis was performed in a Docker container: <a href="https://cloud.docker.com/u/romanhaa/repository/docker/romanhaa/r_github">romanhaa/r_github:2019-04-12_r_3.5.2</a></p>

<p>Obligatory <code>sessionInfo()</code>:</p>

<pre><code class="language-r">R version 3.5.2 (2018-12-20)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Debian GNU/Linux buster/sid

Matrix products: default
BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.8.0
LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.8.0

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C
 [9] LC_ADDRESS=C               LC_TELEPHONE=C
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base

other attached packages:
 [1] Seurat_2.3.4      Matrix_1.2-17     cowplot_0.9.4     reticulate_1.11.1
 [5] colorout_1.2-0    forcats_0.4.0     stringr_1.4.0     dplyr_0.8.0.1
 [9] purrr_0.3.2       readr_1.3.1       tidyr_0.8.3       tibble_2.1.1
[13] ggplot2_3.1.1     tidyverse_1.2.1

loaded via a namespace (and not attached):
  [1] Rtsne_0.15          colorspace_1.4-1    ggridges_0.5.1
  [4] class_7.3-15        modeltools_0.2-22   mclust_5.4.3
  [7] htmlTable_1.13.1    base64enc_0.1-3     proxy_0.4-23
 [10] rstudioapi_0.10     npsurv_0.4-0        bit64_0.9-7
 [13] flexmix_2.3-15      fansi_0.4.0         mvtnorm_1.0-10
 [16] lubridate_1.7.4     xml2_1.2.0          codetools_0.2-16
 [19] splines_3.5.2       R.methodsS3_1.7.1   lsei_1.2-0
 [22] robustbase_0.93-4   knitr_1.22          Formula_1.2-3
 [25] jsonlite_1.6        ica_1.0-2           broom_0.5.2
 [28] cluster_2.0.8       kernlab_0.9-27      png_0.1-7
 [31] R.oo_1.22.0         compiler_3.5.2      httr_1.4.0
 [34] backports_1.1.3     assertthat_0.2.1    lazyeval_0.2.2
 [37] cli_1.1.0           lars_1.2            acepack_1.4.1
 [40] htmltools_0.3.6     tools_3.5.2         igraph_1.2.4
 [43] gtable_0.3.0        glue_1.3.1          reshape2_1.4.3
 [46] RANN_2.6.1          Rcpp_1.0.1          cellranger_1.1.0
 [49] trimcluster_0.1-2.1 ape_5.3             gdata_2.18.0
 [52] nlme_3.1-138        iterators_1.0.10    fpc_2.1-11.1
 [55] lmtest_0.9-36       gbRd_0.4-11         xfun_0.6
 [58] rvest_0.3.2         irlba_2.3.3         gtools_3.8.1
 [61] DEoptimR_1.0-8      zoo_1.8-5           MASS_7.3-51.3
 [64] scales_1.0.0        hms_0.4.2           doSNOW_1.0.16
 [67] parallel_3.5.2      RColorBrewer_1.1-2  pbapply_1.4-0
 [70] gridExtra_2.3       segmented_0.5-3.0   rpart_4.1-13
 [73] latticeExtra_0.6-28 stringi_1.4.3       foreach_1.4.4
 [76] checkmate_1.9.1     caTools_1.17.1.2    bibtex_0.4.2
 [79] dtw_1.20-1          Rdpack_0.10-1       SDMTools_1.1-221
 [82] rlang_0.3.4         pkgconfig_2.0.2     prabclus_2.2-7
 [85] bitops_1.0-6        lattice_0.20-38     ROCR_1.0-7
 [88] htmlwidgets_1.3     labeling_0.3        bit_1.1-14
 [91] tidyselect_0.2.5    plyr_1.8.4          magrittr_1.5
 [94] R6_2.4.0            snow_0.4-3          gplots_3.0.1.1
 [97] generics_0.0.2      Hmisc_4.2-0         pillar_1.3.1
[100] haven_2.1.0         foreign_0.8-71      withr_2.1.2
[103] mixtools_1.1.0      fitdistrplus_1.0-14 survival_2.44-1.1
[106] nnet_7.3-12         tsne_0.1-3          hdf5r_1.1.1
[109] modelr_0.1.4        crayon_1.3.4        KernSmooth_2.23-15
[112] utf8_1.1.4          grid_3.5.2          readxl_1.3.1
[115] data.table_1.12.2   metap_1.1           digest_0.6.18
[118] diptest_0.75-7      R.utils_2.8.0       stats4_3.5.2
[121] munsell_0.5.0
</code></pre>

<p>And Python + scanpy version:</p>

<pre><code class="language-r">system(&quot;python3 --version&quot;)
Python 3.7.3rc1

system(&quot;python3 -c 'import scanpy; print(scanpy.__version__)'&quot;)
1.4
</code></pre>

          </div>

        </div>
      </div>
    </div>
  </div>

      </div>
<footer class="footer">
  <div class="container">
    <div class="row">
      <div class="col-md-4 col-sm-4 text-center text-lg-left">
        &copy; Copyright Roman Hillje - All rights reserved
      </div>
      <section class="col-md-4 col-sm-4 text-center">
        <a target="_blank" href="https://github.com/romanhaa"><i class="fab fa-github" style="color: rgba(0,0,0,.44); font-size: 2rem; margin-left: 10px" aria-hidden="true"></i></a>
        <a target="_blank" href="https://www.twitter.com/fakechek1"><i class="fab fa-twitter" style="color: rgba(0,0,0,.44); font-size: 2rem; margin-left: 10px" aria-hidden="true"></i></a>
        <a target="_blank" href="https://linkedin.com/in/roman.hillje"><i class="fab fa-linkedin" style="color: rgba(0,0,0,.44); font-size: 2rem; margin-left: 10px" aria-hidden="true"></i></a>
      </section>
      <div class="col-md-4 col-sm-4 text-center text-lg-right">
        Adapted from <a target="_blank" href="https://www.wowthemes.net">Mediumish Theme</a>
      </div>
    </div>
  </div>
</footer>
</div>

<script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
<script src="/js/mediumish.js"></script>

  </body>
</html>
